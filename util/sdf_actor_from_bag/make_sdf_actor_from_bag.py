#!/usr/bin/env python

"""
make_sdf_actor_from_bag.py
Populates an SDF file with an Actor that is animated to move in the same path as a frame from a bag file. Example
usage for EVGP robot (and using EVGP mesh for opponent):
    make_sdf_actor_from_bag.py --in-bag ~/Downloads/sim_lap_tf.bag \
                               --out-sdf ~/catkin_ws/src/roboracing-software/rr_gazebo/models/Opponent/model.sdf \
                               --world-frame world --robot-frame body_visual_origin --timestep 0.3 --time-warp 1.1
"""

from __future__ import print_function

import copy
import time
import argparse

import rospy
import rosbag
import tf
from tf import transformations
import numpy as np


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--in-bag", type=str, required=True, help="path in input rosbag file")
    parser.add_argument("--out-sdf", type=str, required=True, help="path to output sdf file")
    parser.add_argument("--world-frame", type=str, default="world", help="world reference frame (default: 'world')")
    parser.add_argument("--robot-frame", type=str, default="base_footprint",
                        help="moving reference frame (default: 'base_footprint')")
    parser.add_argument("--timestep", default=0.5, type=float,
                        help="time delta between output trajectory waypoints in seconds (default 0.5)")
    parser.add_argument("--time-warp", default=1.0, type=float,
                        help="multiply timestamps by this value, so larger values mean slower motion")
    args = parser.parse_args()

    bag = rosbag.Bag(args.in_bag, 'r')

    unordered_tfs = []
    for topic, tf_msg, t in bag.read_messages(topics=["/tf", "/tf_static"]):
        for transform_stamped in tf_msg.transforms:
            unordered_tfs.append(transform_stamped)
            if topic == "/tf_static":
                t = bag.get_start_time()
                while t <= bag.get_end_time():
                    ts2 = copy.deepcopy(transform_stamped)
                    ts2.header.stamp = rospy.Time.from_sec(t)
                    unordered_tfs.append(ts2)
                    t += args.timestep / 2.0

    ordered_tfs = sorted(unordered_tfs, key=lambda T: T.header.stamp.to_sec())

    transformer = tf.Transformer(interpolate=True, cache_time=rospy.Duration.from_sec(args.timestep * 2.0))

    stamped_poses = []
    next_time = 0
    for T in ordered_tfs:
        transformer.setTransform(T)
        msg_time = T.header.stamp.to_sec()
        if msg_time >= next_time:
            if transformer.canTransform(args.world_frame, args.robot_frame, rospy.Time(0)):
                trans, rot = transformer.lookupTransform(args.world_frame, args.robot_frame, rospy.Time(0))
                stamped_poses.append((trans, rot, msg_time - bag.get_start_time()))

            while next_time <= msg_time:
                next_time += args.timestep

    template_begin = """<?xml version="1.0" ?>
<!-- THIS FILE HAS BEEN AUTO-GENERATED BY ROBORACING util/make_sdf_actor_from_bag.py. EDIT AT YOUR OWN PERIL -->
<sdf version="1.6">
    <actor name="actor{}">
        <pose>0 0 0 0 0 0</pose>
        <link name="link">
            <visual name="visual">
                <geometry>
                    <mesh>
                        <uri>model://meshes/EVGP_robot.STL</uri>
                        <scale>0.001 0.001 0.001</scale>
                    </mesh>
                </geometry>
            </visual>
            <collision name="collide">
                <geometry>
                    <mesh>
                        <uri>model://meshes/EVGP_robot.STL</uri>
                        <scale>0.001 0.001 0.001</scale>
                    </mesh>
                </geometry>
            </collision>
        </link>
        <script>
            <loop>true</loop>
            <delay_start>0</delay_start>
            <auto_start>true</auto_start>
            <trajectory id="0" type="driving">""".format(int(time.time()))
    template_end = """
            </trajectory>
        </script>
    </actor>
</sdf>"""

    waypoints_body = str()
    for trans, rot, t in stamped_poses:
        roll, pitch, yaw = transformations.euler_from_quaternion(rot)
        x, y, z = trans
        x, y, z, roll, pitch, yaw = [round(v, 3) for v in [x, y, z, roll, pitch, yaw]]
        waypoint = """
                <waypoint>
                    <time>{}</time>
                    <pose>{} {} {} {} {} {}</pose>
                </waypoint>""".format(t * args.time_warp, x, y, z, roll, pitch, yaw)
        waypoints_body += waypoint

    sdf_text = template_begin + waypoints_body + template_end
    with open(args.out_sdf, 'w') as f:
        f.write(sdf_text)


if __name__ == '__main__':
    main()
